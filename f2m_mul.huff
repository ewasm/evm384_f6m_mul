


template<val>
#define macro AWKWARD_ADD = takes(0) returns(1) {
  <val>
}

#define macro F2M_MUL_BUFFER = takes(0) returns(1) {
    0	// TODO: update this variable to the fixed memory buffer offset used by F2M_MUL
}

#define macro F2M_MUL = takes(4) returns(0) {
  // input stack shoud be:
  //  &out &x &y &mod inv
  //  where &out is top of stack, and x is the 48-byte value at memory location &x

  // prepare for computation by setting up stack to:
  //   &x0 &x1 &y0 &y1 &mod inv &out0 &out1
  dup1
  48
  add		// &out1
  dup2		// &out0
  dup7		// inv
  dup7		// &mod
  dup7
  48
  add		// &y1
  dup8		// &y0
  dup8
  48
  add		// &x1
  dup9		// &x0

  // Will use memory offsets for temporary values
  //F2M_MUL_BUFFER()+240	// &zero
  //F2M_MUL_BUFFER()+96		// &tmp1
  //F2M_MUL_BUFFER()+144	// &tmp2
  //F2M_MUL_BUFFER()+192	// &tmp3
  
  // &tmp1 = x0*y0
  dup6			// inv
  dup6			// &mod
  dup5			// &y0
  dup4			// &x0
  AWKWARD_ADD<F2M_MUL_BUFFER+96>()	// &tmp1
  mulmodmont384

  // &tmp2 = x1*y1
  dup6			// inv
  dup6			// &mod
  dup6			// &y1
  dup5			// &x1
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  mulmodmont384
  
  // &tmp3 = 0-&tmp2
  dup5			// &mod
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  AWKWARD_ADD<F2M_MUL_BUFFER+48>()	// &zero
  AWKWARD_ADD<F2M_MUL_BUFFER+192>()	// &tmp3
  submod384

  // &out0 = &tmp1 + &tmp3
  dup5			// &mod
  AWKWARD_ADD<F2M_MUL_BUFFER+192>()	// &tmp3
  AWKWARD_ADD<F2M_MUL_BUFFER+96>()	// &tmp1
  dup10			// &out0
  addmod384
  
  // &tmp1 = &tmp1 + &tmp2
  dup5			// &mod
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  AWKWARD_ADD<F2M_MUL_BUFFER+96>()	// &tmp1
  AWKWARD_ADD<F2M_MUL_BUFFER+96>()	// &tmp1
  addmod384
  
  // recall, stack looks like:
  //   &x0 &x1 &y0 &y1 &mod inv &out0 &out1

  // &tmp2 = &x0 + &x1
  dup5
  dup2
  dup4
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  addmod384
  
  // &tmp3 = &y0 + &y1
  dup5
  dup4
  dup6
  AWKWARD_ADD<F2M_MUL_BUFFER+192>()	// &tmp3
  addmod384

  // &tmp2 = &tmp2 * &tmp3
  dup6
  dup6
  AWKWARD_ADD<F2M_MUL_BUFFER+192>()	// &tmp3
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  mulmodmont384

  // &out1 = &tmp2 - &tmp1
  dup5
  AWKWARD_ADD<F2M_MUL_BUFFER+96>()	// &tmp1
  AWKWARD_ADD<F2M_MUL_BUFFER+144>()	// &tmp2
  dup11			// &out1
  submod384

  // clear stack
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
}

#define macro F2M_MUL_TESTER_HARDCODED = takes(0) returns(0) {
  // set up memory
  // x0
  0x0daa35e7a880a2ca3bcea128c5c8d17202945981a13aec134d10c051c1fa23c0
  300
  mstore
  0x6b3088c3a380f4b8b1f598e5f390298f00000000000000000000000000000000
  332
  mstore
  // x1
  0x0918e9882e10abce5a0f55c6916e3be87e5dc68b9d3324db632d33c3fb53868f
  348
  mstore
  0x77c0488c7e3ab230d54c6d90277a2d9900000000000000000000000000000000
  380
  mstore
  //y0
  0x15e1e13af71de9928b9b1631a9ecad43670a33daa7a418b44f0090b4b602e334
  500
  mstore
  0xf47665551a973a7a4c64af08c847d3ec00000000000000000000000000000000
  532
  mstore
  //y1
  0x0d36ade56247620236b05713353330909e7bb1d29bbceb438dc379ad239bf693
  548
  mstore
  0x2d43750eb8e3d564d743e8119e82a21200000000000000000000000000000000
  580
  mstore
  // mod for bls12-381
  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f624
  700
  mstore
  0x1eabfffeb153ffffb9feffffffffaaab00000000000000000000000000000000
  732
  mstore
  // inv for bls12-381
  0x89f3fffcfffcfffd000000000000000000000000000000000000000000000000
  748
  mstore

  // set up stack for f2m_mul
  0x89f3fffcfffcfffd	// inv
  700			// mod
  500			// y
  300			// x
  0			// out

  // call f2m_mul
  F2M_MUL()

  // store first 32 bytes of out to storage slot 0x00
  0
  mload
  0
  sstore
  // store second 32 bytes of out to storage slot 0x01
  32
  mload
  1
  sstore
  // store third 32 bytes of out to storage slot 0x02
  64
  mload
  2
  sstore
}

#define macro F2M_MUL_TESTER_CALLDATA = takes(0) returns(0) {
  // set up memory
  248
  0
  300
  calldatacopy
  // calldata is concatenation of: x0 x1 y0 y1 mod inv
  // eg calldata:
  //0daa35e7a880a2ca3bcea128c5c8d17202945981a13aec134d10c051c1fa23c06b3088c3a380f4b8b1f598e5f390298f
  //0918e9882e10abce5a0f55c6916e3be87e5dc68b9d3324db632d33c3fb53868f77c0488c7e3ab230d54c6d90277a2d99
  //15e1e13af71de9928b9b1631a9ecad43670a33daa7a418b44f0090b4b602e334f47665551a973a7a4c64af08c847d3ec
  //0d36ade56247620236b05713353330909e7bb1d29bbceb438dc379ad239bf6932d43750eb8e3d564d743e8119e82a212
  //1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab89f3fffcfffcfffd

  // set up stack for f2m_mul
  516 mload 0xffffffffffffffff and	// inv, after masking out everything but least significant 8 bytes
  492			// mod
  396			// y
  300			// x
  0			// out

  // call f2m_mul
  F2M_MUL()

  // store first 32 bytes of out to storage slot 0x00
  0
  mload
  0
  sstore
  // store second 32 bytes of out to storage slot 0x01
  32
  mload
  1
  sstore
  // store third 32 bytes of out to storage slot 0x02
  64
  mload
  2
  sstore
}

#define jumptable F2M_MUL_BENCHER_JUMP_TABLE {
  loop done
}

#define macro F2M_MUL_BENCHER = takes(0) returns(0) {

  // pre-fault the memory
  2000
  mload
  pop

  // set up memory
  248
  0
  300
  calldatacopy
  // calldata is concatenation of: x0 x1 y0 y1 mod inv
  // eg calldata:
  //0daa35e7a880a2ca3bcea128c5c8d17202945981a13aec134d10c051c1fa23c06b3088c3a380f4b8b1f598e5f390298f
  //0918e9882e10abce5a0f55c6916e3be87e5dc68b9d3324db632d33c3fb53868f77c0488c7e3ab230d54c6d90277a2d99
  //15e1e13af71de9928b9b1631a9ecad43670a33daa7a418b44f0090b4b602e334f47665551a973a7a4c64af08c847d3ec
  //0d36ade56247620236b05713353330909e7bb1d29bbceb438dc379ad239bf6932d43750eb8e3d564d743e8119e82a212
  //1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab89f3fffcfffcfffd

  1	// iterator
  
loop:
  // set up stack for f2m_mul
  516 mload 0xffffffffffffffff and	// inv, after masking out everything but least significant 8 bytes
  492			// mod
  396			// y
  300			// x
  0			// out
  // call f2m_mul
  F2M_MUL()
  // jump back to loop if iter variable < 10000
  __tablesize(F2M_MUL_BENCHER_JUMP_TABLE) __tablestart(F2M_MUL_BENCHER_JUMP_TABLE) 1000 codecopy
  1000 dup2 1 add swap2 pop dup2 100 lt 32 mul add mload jump	// where the number before lt is iter_count

done:
  // store first 32 bytes of out to storage slot 0x00
  0
  mload
  0
  sstore
  // store second 32 bytes of out to storage slot 0x01
  32
  mload
  1
  sstore
  // store third 32 bytes of out to storage slot 0x02
  64
  mload
  2
  sstore
   
}

