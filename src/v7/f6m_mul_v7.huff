

// this is a dummy macro which lets me evaluate arithmetic at compile-time
template<val>
#define macro EVAL_ARITHMETIC = takes(0) returns(1) {
  <val>
}


// these are various hard-coded memory offsets which we use for various buffers

#define macro NUM_BYTES = takes(0) returns(1) {
  48
}

#define macro F6M_MUL_OUT = takes(0) returns(1) {	// 6 values
  1344	// EVAL_ARITHMETIC<0x1c*48>()
}

#define macro F1_TMP = takes(0) returns(1) {	// 3 values
  1200	// EVAL_ARITHMETIC<0x19*48>()
}

#define macro F6M_MUL_R_TMP = takes(0) returns(1) {	// 6 values, but we have 8 values, first two zeros
  912	// EVAL_ARITHMETIC<0x13*48>()
}

#define macro F6M_MUL_BUFFER_AA_BB_CC = takes(0) returns(1) {	// 6 values
  624 	// EVAL_ARITHMETIC<0x0d*48>()
}

#define macro F6_INPUTABC = takes(0) returns(1) {	// 6 values
  48	// EVAL_ARITHMETIC<0x01*48>()
}

#define macro MOD_OFFSET = takes(0) returns(1) {	// 1.5 values
  0x660	// EVAL_ARITHMETIC<256*48>()
}


// next we have various macros for f2m and f6m arithmetic, including multiplication.


/*
Convention: memory is set up as follows
<idx> <variable>, where <idx> is the memory location divided by 48 (i.e. the idx'th 48-byte chunk), and <variable> is the variable name
00 zero
01 a0
02 a1
03 b0
04 b1
05 c0
06 c1
07 A0
08 A1
09 B0
0a B1
0b C0
0c C1
0d aA0
0e aA1
0f bB0
10 bB1
11 cC0
12 cC1
13 tmp10
14 tmp11
15 tmp20
16 tmp21
17 tmp30
18 tmp31
19 f1tmp1
1a f1tmp2
1b f1tmp3
1c out00
1d out01
1e out10
1f out11
20 out20
21 out21
22 mod_and_inv
*/


// this is the main macro for f6m_mul
#define macro F6M_MUL = takes(0) returns(0) {

// first precompute aA, bB, and cC, which we will reuse
// f2m_mul aA = a * A
0x000004b0000000300000015000000660 mulmodmont384			// tmp1 = x0*y0
0x000004e0000000600000018000000660 mulmodmont384			// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000270000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e0000000300000006000000660 addmod384			// tmp2 = x0+x1
0x00000510000001500000018000000660 addmod384			// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x000002a0000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_mul bB = b * B
0x000004b000000090000001b000000660 mulmodmont384			// tmp1 = x0*y0
0x000004e0000000c0000001e000000660 mulmodmont384			// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x000002d0000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000090000000c000000660 addmod384			// tmp2 = x0+x1
0x00000510000001b0000001e000000660 addmod384			// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000300000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_mul cC = c * C
0x000004b0000000f00000021000000660 mulmodmont384			// tmp1 = x0*y0
0x000004e0000001200000024000000660 mulmodmont384			// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000330000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e0000000f00000012000000660 addmod384			// tmp2 = x0+x1
0x00000510000002100000024000000660 addmod384			// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000360000004e0000004b000000660 submod384		// out1 = tmp2-tmp1

// next compute each of the three output f2 points, which are together an f6 point

// F6M_MUL_R2
// f2m_add tmp1 = a + c
0x0000039000000030000000f000000660 addmod384	
0x000003c0000000600000012000000660 addmod384	
// f2m_add tmp2 = A + C
0x000003f0000001500000021000000660 addmod384	
0x00000420000001800000024000000660 addmod384	
// f2m_mul tmp3 = tmp1 * tmp2
0x000004b000000390000003f000000660 mulmodmont384		// tmp1 = x0*y0
0x000004e0000003c00000042000000660 mulmodmont384		// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000450000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000390000003c000000660 addmod384		// tmp2 = x0+x1
0x00000510000003f00000042000000660 addmod384		// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000480000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_add tmp1 = aA + cC
0x00000390000002700000033000000660 addmod384	
0x000003c0000002a00000036000000660 addmod384	
// f2m_sub tmp2 = tmp3 - tmp1
0x000003f0000004500000039000000660 submod384	
0x0000042000000480000003c000000660 submod384	
// f2m_add r2 = 0f + tmp2
0x00000600000002d0000003f000000660 addmod384	
0x00000630000003000000042000000660 addmod384	

// F6M_MUL_R1
// f2m_add tmp1 = a + b
0x00000390000000300000009000000660 addmod384	
0x000003c000000060000000c000000660 addmod384	
// f2m_add tmp2 = A + B
0x000003f000000150000001b000000660 addmod384	
0x0000042000000180000001e000000660 addmod384	
// f2m_mul tmp3 = tmp1 * tmp2
0x000004b000000390000003f000000660 mulmodmont384		// tmp1 = x0*y0
0x000004e0000003c00000042000000660 mulmodmont384		// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000450000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000390000003c000000660 addmod384		// tmp2 = x0+x1
0x00000510000003f00000042000000660 addmod384		// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384 	// tmp2 = tmp2*tmp3
0x00000480000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_add tmp1 = aA + bB
0x0000039000000270000002d000000660 addmod384	
0x000003c0000002a00000030000000660 addmod384	
// f2m_sub tmp2 = tmp3 - tmp1
0x000003f0000004500000039000000660 submod384	
0x0000042000000480000003c000000660 submod384	
// mul_nr2 tmp1 = mulnr2(cC)
0x00000390000003300000036000000660 submod384			// out0 = x0-x1
0x000003c0000003300000036000000660 addmod384			// out1 = x0+x1
// f2m_add r1 = tmp1 + tmp2
0x000005a000000390000003f000000660 addmod384	
0x000005d0000003c00000042000000660 addmod384	

// F6M_MUL_R0
// f2m_add tmp1 = b + c
0x0000039000000090000000f000000660 addmod384	
0x000003c0000000c00000012000000660 addmod384	
// f2m_add tmp2 = B + C
0x000003f0000001b00000021000000660 addmod384	
0x00000420000001e00000024000000660 addmod384	
// f2m_mul tmp3 = tmp1 * tmp2
0x000004b000000390000003f000000660 mulmodmont384		// tmp1 = x0*y0
0x000004e0000003c00000042000000660 mulmodmont384		// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000450000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000390000003c000000660 addmod384		// tmp2 = x0+x1
0x00000510000003f00000042000000660 addmod384		// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000480000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_add tmp1 = bB + cC
0x00000390000002d00000033000000660 addmod384	
0x000003c0000003000000036000000660 addmod384	
// f2m_sub tmp2 = tmp3 - tmp1
0x000003f0000004500000039000000660 submod384	
0x0000042000000480000003c000000660 submod384	
// mul_nr2 tmp3 = tmp2
0x00000450000003f00000042000000660 submod384		// out0 = x0-x1
0x00000480000003f00000042000000660 addmod384		// out1 = x0+x1
// f2m_add r0 = aA + tmp3
0x00000540000002700000045000000660 addmod384	
0x00000570000002a00000048000000660 addmod384	

/*
// more concisely, the above takes input f6 points abc and ABC, and outputs f6 point r. In other words, it inputs six f2 points, a, b, c, A, B, C, and ouputs three f2 points r0, r1, r2. And each f2 point is two f1 points. And an f1 point is a 48-bit integer.

// set up aA, bB, and cC
f2m_mul aA = a * A
f2m_mul bB = b * B
f2m_mul cC = c * C

// F6M_MUL_R2
f2m_add tmp1 = a + c
f2m_add tmp2 = A + C
f2m_mul tmp3 = tmp1 * tmp2
f2m_add tmp1 = aA + cC
f2m_sub tmp2 = tmp3 - tmp1
f2m_add r2 = bB + tmp2

// F6M_MUL_R1
f2m_add tmp1 = a + b
f2m_add tmp2 = A + B
f2m_mul tmp3 = tmp1 * tmp2
f2m_add tmp1 = aA + bB
f2m_sub tmp2 = tmp3 - tmp1
mul_nr2 tmp1 = mulnr2(cC)
f2m_add r1 = tmp1 + tmp2

// F6M_MUL_R0
f2m_add tmp1 = b + c
f2m_add tmp2 = B + C
f2m_mul tmp3 = tmp1 * tmp2
f2m_add tmp1 = bB + cC
f2m_sub tmp2 = tmp3 - tmp1
mul_nr2 tmp3 = tmp2
f2m_add r0 = aA + tmp3
*/

}




///////////////
// f6m_mul test


#define macro F6M_MUL_TEST_HARDCODED = takes(0) returns(0) {

/*
*/
  // set up memory
  // a0
  0x8f2990f3e598f5b1b8f480a3c388306bc023fac151c0104d13ec3aa181599402 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0x72d1c8c528a1ce3bcaa280a8e735aa0d00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // a1
  0x992d7a27906d4cd530b23a7e8c48c0778f8653fbc3332d63db24339d8bc65d7e EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0xe83b6e91c6550f5aceab102e88e9180900000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // b0
  0x7299907146816f08c4c6a394e91374ed6ff3618a57358cfb124ee6ab4c560e5c EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0xac40700b41e2ee8674680728f0c5a61800000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // b1
  0x0fd77f62b39eb952a0f8d21cec1f93b1d62dd7923aa86882ddf7dd4d3532b0b7 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0xede8f3fc89fa4a79574067e2d9a9d20000000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // c0
  0x7a69de46b13d8cb4c4833224aaf9ef7ea6a48975ab35c6e123b8539ab84c381a EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0x2533401a73c4e79f47d714899d01ac1300000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // c1
  0xa9fa0b0d8156c36a1a9ddacb73ef278f4d149b560e88789f2bfeb9f708b6cc2f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0x988927bfe0186d5bf9cb40cb07f21b1800000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // A0
  0xecd347c808af644c7a3a971a556576f434e302b6b490004fb418a4a7da330a67 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0x43adeca931169b8b92e91df73ae1e11500000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // A1
  0x12a2829e11e843d764d5e3b80e75432d93f69b23ad79c38d43ebbc9bd2b17b9e EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0x903033351357b03602624762e5ad360d00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // B0
  0xd7f9857dce663301f393f9fac66f5c49168494e0d20797a6c4f96327ed4fa47d EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0xd36d0078d217a712407d35046871d40f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // B1
  0x2f1b767f6c1ec190eb76a0bce7906ad2e4a7548d03e8aa745e34e1bf49d83ad6 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0x4c04f57fb4d31039cb4cf01987fda21300000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // C0
  0x7b3f8da2f2ae47885890b0d433a3eeed2f9f37cbcfc444e4f1d880390fcdb765 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0x18d558857be01b2b10a8010bcdc6d60600000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // C1
  0x319c02f6132c8a786377868b5825ada9a5fe303e9ae3b03ce56e90734a17ce97 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0x0c88b321012cf8dabb58211e3d50f61000000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // mod for bls12-381
  0xabaafffffffffeb9ffff53b1feffab1e24f6b0f6a0d23067bf1285f3844b7764 EVAL_ARITHMETIC<MOD_OFFSET*1>() mstore
  0xd7ac4b43b6a71b4b9ae67f39ea11011a00000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+32>() mstore
  // inv for bls12-381
  0xfdfffcfffcfff389000000000000000000000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+48>() mstore



  // call f6m_mul over above memory
  F6M_MUL()

  // return output
  288 F6M_MUL_OUT() return

/*
output should be:
f4f3f4e0a35068eaac665aee2e71f682aecd20923b420023b6d5420ba01ea98287c314107a998a650ab3247ef39c920e
2c9620d993a22bade623d165a9f4aa648af87cb7292b7821c0fcd0adcd14ba655da54df2ad93262e24fc62bcd97e7208
ead1838e6c5e168543093c87eaeb576f940670026292dcb7a812600f4fb20a281be71ce1ef79f675e4a283b73906ca17
9c8b2c76405445b20dd7635d562309f69c2c87601d9055a5e10df2ea1d28237fafd0d32f7e8c19d4cd5a3d1ef65b120b
40591ef0c74dbec983b7bef145a87957c1e09049dbc85fbb3e9bb1174892ee83294ef8c4a5954fffbff4ca6aca74c718
9b242b8f1c5d63bb525121bd68eda084ab7e6d015052d5adeb79ddb24091d2a8e5b1da00212d0e6c11f01d2379011308
*/

}


///////////////
// f6m_mul benchmark

#define macro F6M_MUL_BENCH_NUM_ITERS = takes(0) returns(1) {
  135
}

#define jumptable F6M_MUL_BENCH_JUMP_TABLE {
  loop done
}

#define macro F6M_MUL_BENCH = takes(0) returns(0) {

/*
*/
  // set up memory
  // a0
  0x8f2990f3e598f5b1b8f480a3c388306bc023fac151c0104d13ec3aa181599402 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0x72d1c8c528a1ce3bcaa280a8e735aa0d00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // a1
  0x992d7a27906d4cd530b23a7e8c48c0778f8653fbc3332d63db24339d8bc65d7e EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0xe83b6e91c6550f5aceab102e88e9180900000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // b0
  0x7299907146816f08c4c6a394e91374ed6ff3618a57358cfb124ee6ab4c560e5c EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0xac40700b41e2ee8674680728f0c5a61800000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // b1
  0x0fd77f62b39eb952a0f8d21cec1f93b1d62dd7923aa86882ddf7dd4d3532b0b7 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0xede8f3fc89fa4a79574067e2d9a9d20000000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // c0
  0x7a69de46b13d8cb4c4833224aaf9ef7ea6a48975ab35c6e123b8539ab84c381a EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0x2533401a73c4e79f47d714899d01ac1300000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // c1
  0xa9fa0b0d8156c36a1a9ddacb73ef278f4d149b560e88789f2bfeb9f708b6cc2f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0x988927bfe0186d5bf9cb40cb07f21b1800000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // A0
  0xecd347c808af644c7a3a971a556576f434e302b6b490004fb418a4a7da330a67 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0x43adeca931169b8b92e91df73ae1e11500000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // A1
  0x12a2829e11e843d764d5e3b80e75432d93f69b23ad79c38d43ebbc9bd2b17b9e EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0x903033351357b03602624762e5ad360d00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // B0
  0xd7f9857dce663301f393f9fac66f5c49168494e0d20797a6c4f96327ed4fa47d EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0xd36d0078d217a712407d35046871d40f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // B1
  0x2f1b767f6c1ec190eb76a0bce7906ad2e4a7548d03e8aa745e34e1bf49d83ad6 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0x4c04f57fb4d31039cb4cf01987fda21300000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // C0
  0x7b3f8da2f2ae47885890b0d433a3eeed2f9f37cbcfc444e4f1d880390fcdb765 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0x18d558857be01b2b10a8010bcdc6d60600000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // C1
  0x319c02f6132c8a786377868b5825ada9a5fe303e9ae3b03ce56e90734a17ce97 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0x0c88b321012cf8dabb58211e3d50f61000000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // mod for bls12-381
  0xabaafffffffffeb9ffff53b1feffab1e24f6b0f6a0d23067bf1285f3844b7764 EVAL_ARITHMETIC<MOD_OFFSET*1>() mstore
  0xd7ac4b43b6a71b4b9ae67f39ea11011a00000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+32>() mstore
  // inv for bls12-381
  0xfdfffcfffcfff389000000000000000000000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+48>() mstore

  // prepare for loop
  1     // iterator, starts at 1 and grows

loop:

  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()

  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()

  __tablesize(F6M_MUL_BENCH_JUMP_TABLE) __tablestart(F6M_MUL_BENCH_JUMP_TABLE) 3000 codecopy    // copy jumpdests to memory offset 3000
  1 add                                 // increment                            [iterator+1]
  dup1 F6M_MUL_BENCH_NUM_ITERS() lt     // compare to max number of iters       [iterator+1 0_or_1]
  32 mul 3000 add       // offset to jump to                                    [iterator+1 1000_or_1032]
  mload jump    // where the number before lt is iter_count

done:
  0xff 0 mstore8 1 0 return	// return a single byte, 0xff, to make sure it executed this far
  //stop

}

