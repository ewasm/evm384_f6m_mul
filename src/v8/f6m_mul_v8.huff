

// this is a dummy macro which lets me evaluate arithmetic at compile-time
template<val>
#define macro EVAL_ARITHMETIC = takes(0) returns(1) {
  <val>
}


// these are various hard-coded memory offsets which we use for various buffers

#define macro NUM_BYTES = takes(0) returns(1) {
  48
}

#define macro F6M_MUL_OUT = takes(0) returns(1) {	// 6 values
  1344	// EVAL_ARITHMETIC<0x1c*48>()
}

#define macro F1_TMP = takes(0) returns(1) {	// 3 values
  1200	// EVAL_ARITHMETIC<0x19*48>()
}

#define macro F6M_MUL_R_TMP = takes(0) returns(1) {	// 6 values, but we have 8 values, first two zeros
  912	// EVAL_ARITHMETIC<0x13*48>()
}

#define macro F6M_MUL_BUFFER_AA_BB_CC = takes(0) returns(1) {	// 6 values
  624 	// EVAL_ARITHMETIC<0x0d*48>()
}

#define macro F6_INPUTABC = takes(0) returns(1) {	// 6 values
  48	// EVAL_ARITHMETIC<0x01*48>()
}

#define macro MOD_OFFSET = takes(0) returns(1) {	// 1.5 values
  0x660	// EVAL_ARITHMETIC<256*48>()
}


// next we have various macros for f2m and f6m arithmetic, including multiplication.


/*
Convention: memory is set up as follows
<idx> <variable>, where <idx> is the memory location divided by 48 (i.e. the idx'th 48-byte chunk), and <variable> is the variable name
00 zero
01 a0
02 a1
03 b0
04 b1
05 c0
06 c1
07 A0
08 A1
09 B0
0a B1
0b C0
0c C1
0d aA0
0e aA1
0f bB0
10 bB1
11 cC0
12 cC1
13 tmp10
14 tmp11
15 tmp20
16 tmp21
17 tmp30
18 tmp31
19 f1tmp1
1a f1tmp2
1b f1tmp3
1c out00
1d out01
1e out10
1f out11
20 out20
21 out21
22 mod_and_inv
*/


// this is the main macro for f6m_mul
#define macro F6M_MUL = takes(0) returns(0) {

// first precompute aA, bB, and cC, which we will reuse
// f2m_mul aA = a * A
0x000004b0000000300000015000000660 mulmodmont384			// tmp1 = x0*y0
0x000004e0000000600000018000000660 mulmodmont384			// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000270000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e0000000300000006000000660 addmod384			// tmp2 = x0+x1
0x00000510000001500000018000000660 addmod384			// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x000002a0000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_mul bB = b * B
0x000004b000000090000001b000000660 mulmodmont384			// tmp1 = x0*y0
0x000004e0000000c0000001e000000660 mulmodmont384			// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x000002d0000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000090000000c000000660 addmod384			// tmp2 = x0+x1
0x00000510000001b0000001e000000660 addmod384			// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000300000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_mul cC = c * C
0x000004b0000000f00000021000000660 mulmodmont384			// tmp1 = x0*y0
0x000004e0000001200000024000000660 mulmodmont384			// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000330000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e0000000f00000012000000660 addmod384			// tmp2 = x0+x1
0x00000510000002100000024000000660 addmod384			// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000360000004e0000004b000000660 submod384		// out1 = tmp2-tmp1

// next compute each of the three output f2 points, which are together an f6 point

// F6M_MUL_R2
// f2m_add tmp1 = a + c
0x0000039000000030000000f000000660 addmod384	
0x000003c0000000600000012000000660 addmod384	
// f2m_add tmp2 = A + C
0x000003f0000001500000021000000660 addmod384	
0x00000420000001800000024000000660 addmod384	
// f2m_mul tmp3 = tmp1 * tmp2
0x000004b000000390000003f000000660 mulmodmont384		// tmp1 = x0*y0
0x000004e0000003c00000042000000660 mulmodmont384		// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000450000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000390000003c000000660 addmod384		// tmp2 = x0+x1
0x00000510000003f00000042000000660 addmod384		// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000480000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_add tmp1 = aA + cC
0x00000390000002700000033000000660 addmod384	
0x000003c0000002a00000036000000660 addmod384	
// f2m_sub tmp2 = tmp3 - tmp1
0x000003f0000004500000039000000660 submod384	
0x0000042000000480000003c000000660 submod384	
// f2m_add r2 = 0f + tmp2
0x00000600000002d0000003f000000660 addmod384	
0x00000630000003000000042000000660 addmod384	

// F6M_MUL_R1
// f2m_add tmp1 = a + b
0x00000390000000300000009000000660 addmod384	
0x000003c000000060000000c000000660 addmod384	
// f2m_add tmp2 = A + B
0x000003f000000150000001b000000660 addmod384	
0x0000042000000180000001e000000660 addmod384	
// f2m_mul tmp3 = tmp1 * tmp2
0x000004b000000390000003f000000660 mulmodmont384		// tmp1 = x0*y0
0x000004e0000003c00000042000000660 mulmodmont384		// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000450000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000390000003c000000660 addmod384		// tmp2 = x0+x1
0x00000510000003f00000042000000660 addmod384		// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384 	// tmp2 = tmp2*tmp3
0x00000480000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_add tmp1 = aA + bB
0x0000039000000270000002d000000660 addmod384	
0x000003c0000002a00000030000000660 addmod384	
// f2m_sub tmp2 = tmp3 - tmp1
0x000003f0000004500000039000000660 submod384	
0x0000042000000480000003c000000660 submod384	
// mul_nr2 tmp1 = mulnr2(cC)
0x00000390000003300000036000000660 submod384			// out0 = x0-x1
0x000003c0000003300000036000000660 addmod384			// out1 = x0+x1
// f2m_add r1 = tmp1 + tmp2
0x000005a000000390000003f000000660 addmod384	
0x000005d0000003c00000042000000660 addmod384	

// F6M_MUL_R0
// f2m_add tmp1 = b + c
0x0000039000000090000000f000000660 addmod384	
0x000003c0000000c00000012000000660 addmod384	
// f2m_add tmp2 = B + C
0x000003f0000001b00000021000000660 addmod384	
0x00000420000001e00000024000000660 addmod384	
// f2m_mul tmp3 = tmp1 * tmp2
0x000004b000000390000003f000000660 mulmodmont384		// tmp1 = x0*y0
0x000004e0000003c00000042000000660 mulmodmont384		// tmp2 = x1*y1
0x0000051000000000000004e000000660 submod384		// tmp3 = zero-tmp2
0x00000450000004b00000051000000660 addmod384		// out0 = tmp1+tmp3
0x000004b0000004b0000004e000000660 addmod384		// tmp1 = tmp1+tmp2
0x000004e000000390000003c000000660 addmod384		// tmp2 = x0+x1
0x00000510000003f00000042000000660 addmod384		// tmp3 = y0+y1
0x000004e0000004e00000051000000660 mulmodmont384		// tmp2 = tmp2*tmp3
0x00000480000004e0000004b000000660 submod384		// out1 = tmp2-tmp1
// f2m_add tmp1 = bB + cC
0x00000390000002d00000033000000660 addmod384	
0x000003c0000003000000036000000660 addmod384	
// f2m_sub tmp2 = tmp3 - tmp1
0x000003f0000004500000039000000660 submod384	
0x0000042000000480000003c000000660 submod384	
// mul_nr2 tmp3 = tmp2
0x00000450000003f00000042000000660 submod384		// out0 = x0-x1
0x00000480000003f00000042000000660 addmod384		// out1 = x0+x1
// f2m_add r0 = aA + tmp3
0x00000540000002700000045000000660 addmod384	
0x00000570000002a00000048000000660 addmod384	

/*
// more concisely, the above takes input f6 points abc and ABC, and outputs f6 point r. In other words, it inputs six f2 points, a, b, c, A, B, C, and ouputs three f2 points r0, r1, r2. And each f2 point is two f1 points. And an f1 point is a 48-bit integer.

// set up aA, bB, and cC
f2m_mul aA = a * A
f2m_mul bB = b * B
f2m_mul cC = c * C

// F6M_MUL_R2
f2m_add tmp1 = a + c
f2m_add tmp2 = A + C
f2m_mul tmp3 = tmp1 * tmp2
f2m_add tmp1 = aA + cC
f2m_sub tmp2 = tmp3 - tmp1
f2m_add r2 = bB + tmp2

// F6M_MUL_R1
f2m_add tmp1 = a + b
f2m_add tmp2 = A + B
f2m_mul tmp3 = tmp1 * tmp2
f2m_add tmp1 = aA + bB
f2m_sub tmp2 = tmp3 - tmp1
mul_nr2 tmp1 = mulnr2(cC)
f2m_add r1 = tmp1 + tmp2

// F6M_MUL_R0
f2m_add tmp1 = b + c
f2m_add tmp2 = B + C
f2m_mul tmp3 = tmp1 * tmp2
f2m_add tmp1 = bB + cC
f2m_sub tmp2 = tmp3 - tmp1
mul_nr2 tmp3 = tmp2
f2m_add r0 = aA + tmp3
*/

}




///////////////
// f6m_mul test


#define macro F6M_MUL_TEST_HARDCODED = takes(0) returns(0) {

  // set up memory
  // a0
  0x0daa35e7a880a2ca3bcea128c5c8d17202945981a13aec134d10c051c1fa23c0 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0x6b3088c3a380f4b8b1f598e5f390298f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // a1
  0x0918e9882e10abce5a0f55c6916e3be87e5dc68b9d3324db632d33c3fb53868f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0x77c0488c7e3ab230d54c6d90277a2d9900000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // b0
  0x18a6c5f02807687486eee2410b7040ac5c0e564cabe64e12fb8c35578a61f36f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0xed7413e994a3c6c4086f81467190997200000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // b1
  0x00d2a9d9e2674057794afa89fcf3e8edb7b032354dddf7dd8268a83a92d72dd6 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0xb1931fec1cd2f8a052b99eb3627fd70f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // c0
  0x13ac019d8914d7479fe7c4731a4033251a384cb89a53b823e1c635ab7589a4a6 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0x7eeff9aa243283c4b48c3db146de697a00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // c1
  0x181bf207cb40cbf95b6d18e0bf2789982fccb608f7b9fe2b9f78880e569b144d EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0x8f27ef73cbda9d1a6ac356810d0bfaa900000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // A0
  0x15e1e13af71de9928b9b1631a9ecad43670a33daa7a418b44f0090b4b602e334 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0xf47665551a973a7a4c64af08c847d3ec00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // A1
  0x0d36ade56247620236b05713353330909e7bb1d29bbceb438dc379ad239bf693 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0x2d43750eb8e3d564d743e8119e82a21200000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // B0
  0x0fd4716804357d4012a717d278006dd37da44fed2763f9c4a69707d2e0948416 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0x495c6fc6faf993f3013366ce7d85f9d700000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // B1
  0x13a2fd8719f04ccb3910d3b47ff5044cd63ad849bfe1345e74aae8038d54a7e4 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0xd26a90e7bca076eb90c11e6c7f761b2f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // C0
  0x06d6c6cd0b01a8102b1be07b8558d51865b7cd0f3980d8f1e444c4cfcb379f2f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0xedeea333d4b090588847aef2a28d3f7b00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // C1
  0x10f6503d1e2158bbdaf82c0121b3880c97ce174a73906ee53cb0e39a3e30fea5 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0xa9ad25588b867763788a2c13f6029c3100000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // mod for bls12-381
  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f624 EVAL_ARITHMETIC<MOD_OFFSET*1>() mstore
  0x1eabfffeb153ffffb9feffffffffaaab00000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+32>() mstore
  // inv for bls12-381
  0x89f3fffcfffcfffd000000000000000000000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+48>() mstore



  // call f6m_mul over above memory
  F6M_MUL()

  // return output
  288 F6M_MUL_OUT() return

/*
output should be the following but big-endian:
f4f3f4e0a35068eaac665aee2e71f682aecd20923b420023b6d5420ba01ea98287c314107a998a650ab3247ef39c920e
2c9620d993a22bade623d165a9f4aa648af87cb7292b7821c0fcd0adcd14ba655da54df2ad93262e24fc62bcd97e7208
ead1838e6c5e168543093c87eaeb576f940670026292dcb7a812600f4fb20a281be71ce1ef79f675e4a283b73906ca17
9c8b2c76405445b20dd7635d562309f69c2c87601d9055a5e10df2ea1d28237fafd0d32f7e8c19d4cd5a3d1ef65b120b
40591ef0c74dbec983b7bef145a87957c1e09049dbc85fbb3e9bb1174892ee83294ef8c4a5954fffbff4ca6aca74c718
9b242b8f1c5d63bb525121bd68eda084ab7e6d015052d5adeb79ddb24091d2a8e5b1da00212d0e6c11f01d2379011308
*/

}


///////////////
// f6m_mul benchmark

#define macro F6M_MUL_BENCH_NUM_ITERS = takes(0) returns(1) {
  135
}

#define jumptable F6M_MUL_BENCH_JUMP_TABLE {
  loop done
}

#define macro F6M_MUL_BENCH = takes(0) returns(0) {

  // set up memory
  // a0
  0x0daa35e7a880a2ca3bcea128c5c8d17202945981a13aec134d10c051c1fa23c0 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0x6b3088c3a380f4b8b1f598e5f390298f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // a1
  0x0918e9882e10abce5a0f55c6916e3be87e5dc68b9d3324db632d33c3fb53868f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0x77c0488c7e3ab230d54c6d90277a2d9900000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // b0
  0x18a6c5f02807687486eee2410b7040ac5c0e564cabe64e12fb8c35578a61f36f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0xed7413e994a3c6c4086f81467190997200000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // b1
  0x00d2a9d9e2674057794afa89fcf3e8edb7b032354dddf7dd8268a83a92d72dd6 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0xb1931fec1cd2f8a052b99eb3627fd70f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // c0
  0x13ac019d8914d7479fe7c4731a4033251a384cb89a53b823e1c635ab7589a4a6 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0x7eeff9aa243283c4b48c3db146de697a00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // c1
  0x181bf207cb40cbf95b6d18e0bf2789982fccb608f7b9fe2b9f78880e569b144d EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0x8f27ef73cbda9d1a6ac356810d0bfaa900000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // A0
  0x15e1e13af71de9928b9b1631a9ecad43670a33daa7a418b44f0090b4b602e334 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0>() mstore
  0xf47665551a973a7a4c64af08c847d3ec00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*0+32>() mstore
  // A1
  0x0d36ade56247620236b05713353330909e7bb1d29bbceb438dc379ad239bf693 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1>() mstore
  0x2d43750eb8e3d564d743e8119e82a21200000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*0+NUM_BYTES*1+32>() mstore
  // B0
  0x0fd4716804357d4012a717d278006dd37da44fed2763f9c4a69707d2e0948416 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0>() mstore
  0x495c6fc6faf993f3013366ce7d85f9d700000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*0+32>() mstore
  // B1
  0x13a2fd8719f04ccb3910d3b47ff5044cd63ad849bfe1345e74aae8038d54a7e4 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1>() mstore
  0xd26a90e7bca076eb90c11e6c7f761b2f00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*1+NUM_BYTES*1+32>() mstore
  // C0
  0x06d6c6cd0b01a8102b1be07b8558d51865b7cd0f3980d8f1e444c4cfcb379f2f EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0>() mstore
  0xedeea333d4b090588847aef2a28d3f7b00000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*0+32>() mstore
  // C1
  0x10f6503d1e2158bbdaf82c0121b3880c97ce174a73906ee53cb0e39a3e30fea5 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1>() mstore
  0xa9ad25588b867763788a2c13f6029c3100000000000000000000000000000000 EVAL_ARITHMETIC<F6_INPUTABC+NUM_BYTES*6+NUM_BYTES*2*2+NUM_BYTES*1+32>() mstore
  // mod for bls12-381
  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f624 EVAL_ARITHMETIC<MOD_OFFSET*1>() mstore
  0x1eabfffeb153ffffb9feffffffffaaab00000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+32>() mstore
  // inv for bls12-381
  0x89f3fffcfffcfffd000000000000000000000000000000000000000000000000 EVAL_ARITHMETIC<MOD_OFFSET+48>() mstore

  // prepare for loop
  1     // iterator, starts at 1 and grows

loop:

  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()

  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()
  F6M_MUL()

  __tablesize(F6M_MUL_BENCH_JUMP_TABLE) __tablestart(F6M_MUL_BENCH_JUMP_TABLE) 3000 codecopy    // copy jumpdests to memory offset 3000
  1 add                                 // increment                            [iterator+1]
  dup1 F6M_MUL_BENCH_NUM_ITERS() lt     // compare to max number of iters       [iterator+1 0_or_1]
  32 mul 3000 add       // offset to jump to                                    [iterator+1 1000_or_1032]
  mload jump    // where the number before lt is iter_count

done:
  0xff 0 mstore8 1 0 return	// return a single byte, 0xff, to make sure it executed this far
  //stop

}

